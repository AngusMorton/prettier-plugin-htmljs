export interface Input<T> {
  options: T[];
  onSelect: (newVal: T) => unknown;
}

static function staticFn() {
  // can NOT use `T` here
}
$ {
  const instanceFn = (val: T) => {
    // can use `T` here
  };
}
// can use `as T` here

<select on-input((evt) => input.onSelect(options[evt.target.value] as T))>
  <for|value, i| of=input.options>
    <option value=i>${value}</option>
  </for>
</select>

<fancy-table data=people>
  <@column|person: string|> Name: ${person}</@column>
  <@column|
    person: string,
    anotherPerson: string,
    aThirdPerson: string,
    aFourthPerson: string,
  |>
    Age:
    ${person}
  </@column>
</fancy-table>

<my-tag<MyType, MyOtherType> my-attr="my-string" />
<my-tag<MyType, MyOtherType>|x| />
<my-tag<MyType>|x| my-attr="my-string" />
<my-tag<MyType>|x| />
<my-tag<MyType1><MyOtherType>|x| />
<my-tag<
  A,
  Whole,
  Bunch,
  Of,
  Tag,
  Attribute,
  Types,
  That,
  Need,
  To,
  Wrap,
  To,
  The,
  Next,
  Line,
>
<
  A,
  Whole,
  Bunch,
  Of,
  Tag,
  Parameter,
  Types,
  That,
  Need,
  To,
  Wrap,
  To,
  The,
  Next,
  Line,
>|x| />
<my-tag<
  T extends
    keyof (typeof SuperLongImportedVariableName)["member1"]["member2"]["member3"],
  K extends T extends string
    ? MyType["member1"]["member2"]["member3"]
    : MyOtherType,
>|x| />

<some-component number=1 as const names=[] as string[] />
